<element name="smart-post" attributes="model editable fixed onEditMode" on-dblclick="editModeOn" on-keyup="keyUp">
  <template>
    <style>
      @host {
        smart-post {
          position: relative;
          display: block;
          width: 600px;
          margin: 20px;
          padding: 5px;
        }
      }
      #bodyContainer {
        width: 595px;
      }
      .body {
        min-height: 2em;
        width: 100%;
        height: 100%;
      }
      #title {
        margin-top: 0px;
        min-height: 1em;
      }
      #editableBody {
        border: none;
        height: 3.5em;
        bottom: 10px;
        margin: 0px;
        padding: 0px;
      }
      button {
        float: right;
        background: none;
        border: none;
        cursor: pointer;
      }
      button:hover {
        color: rgb(206, 26, 26);
      }
      #remove {
        top: 0px;
        right: 0px;
        font-size: 15px;
      }
      .clear {
        clear: both;
      }
      .updeatable {
        transition: opacity 1s;
      }
    </style>
    <button id="remove" style="display:none;" on-click="remove">X</button>
    <div class="clear"></div>
    <h1 id="title" class="updeatable" contentEditable="{{onEditMode}}" on-keyup="updateTitle" on-keydown="preventNewLine" on-focusout="editModeOff" on-transitionend="titleTransitionEnded"></h1>
    <div id="bodyContainer">
      <div id="body" class="body updeatable" on-transitionend="bodyTransitionEnded"></div>
      <textarea id="editableBody" class="body" style="display:none;" value="{{model.body}}" on-focusout="editModeOff"></textarea>
    </div>
    <button id="save" style="display:none;" on-click="save">Save</button>
    <div class="clear"></div>
  </template>
  <script>
    Polymer.register(this, {
  ready: function() {
    var self = this;
    this._ready = true;
    this.$.title.innerHTML = this.model.title;
    this.parseBody();
  },

  set editable(flag) {
    this._editable = flag;
    this.updateRemoveButton();
  },
  get editable() {
    return this._editable || null;
  },

  set fixed(flag) {
    this._fixed = flag;
    this.updateRemoveButton();
  },
  get fixed() {
    return this._fixed || null;
  },

  set model(model) {
    if (typeof model === "string") {
      model = JSON.parse(model);
    }
    this._model = model;
    this.observeModel();
  },
  get model() {
    if (!this._model) {
      this.model = {
        title: "",
        body: ""
      };
    }
    return this._model;
  },

  updateRemoveButton: function() {
    this.$.remove.style.display = this.editable && !this.fixed ? "block" : "none";
  },
  observeModel: function() {
    var self = this;

    Object.keys(this._model).forEach(function(key) {
      var fname = key + "Changed",
      observer;

      observer = new PathObserver(self._model, key, function(inNew, inOld) {
        if (inNew === inOld) return;
        console.log(key);
        if (typeof self[fname] === "function") self[fname](inOld);
      });
      Polymer.registerObserver(self, "property", key, observer);
      if (self[fname]) self[fname]();
    });
  },
  parse: require("marked"),
  editModeOn: function() {
    if (!this.editable) return;
    this.$.editableBody.style.display = "block"; 
    this.$.editableBody.style.height = (this.$.body.clientHeight) + "px"; 
    this.$.body.style.display = "none"; 
    this.onEditMode = true;
  },
  editModeOff: function() {
    if (!this.onEditMode) return;
    this.$.editableBody.style.display = "none"; 
    this.$.body.style.display = "block";
    this.parseBody();
    this.onEditMode = false;
  },
  updateTitle: function() {
    this.model.title = this.$.title.innerHTML;
  },
  titleChanged: function(old) {
    if (!this._ready) return;
    this.$.save.style.display = old && this.model.title && this.model.title !== "" ? "block" : "none";
    if (!this.onEditMode) {
      this.$.title.style.opacity = 0;
    }
  },
  titleTransitionEnded: function() {
    if (this.$.title.style.opacity > 0) return;
    this.$.title.innerHTML = this.model.title;
    this.dispatchEvent(new CustomEvent("foreign:update:title"));
    this.$.title.style.opacity = 1;
  },
  bodyChanged: function(old) {
    if (!this._ready) return;
    this.$.save.style.display = old && this.model.body && this.model.body !== "" ? "block" : "none";
    if (!this.onEditMode) {
      this.$.body.style.opacity = 0;
    }
  },
  bodyTransitionEnded: function() {
    if (this.$.body.style.opacity > 0) return;
    this.parseBody();
    this.dispatchEvent(new CustomEvent("foreign:update:body"));
    this.$.body.style.opacity = 1;
  },
  parseBody: function() {
    if (!this._ready) return;
    //Just to kickstart it, he's a little shy...
    if (!this.$.editableBody.value) {
      this.$.editableBody.value = this.model.body;
    }
    this.$.body.innerHTML = this.parse(this.$.editableBody.value);
    this.fire("update");
  },
  remove: function() {
    if (!this.parentNode) return;
    this.parentNode.removeChild(this);
    this.fire("delete");
  },
  save: function() {
    this.$.save.style.display = "none";
    this.fire("save");
  },
  keyUp: function(e) {
    switch (e.keyCode) {
      case 13: //ENTER
        this.save();
      case 27: //ESC
        this.editModeOff();
    }
  },
  preventNewLine: function(e) {
    if (e.keyCode === 13) {
      e.preventDefault();
    }
  }
});
  </script>
</element>
